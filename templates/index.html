<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>SpinForge – Custom Cycling Workouts in Seconds</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <script src="https://unpkg.com/htmx.org@1.9.12"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes slide-up {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .animate-slide-up {
      animation: slide-up 0.3s ease-out;
    }
    
    .wf-bar {
      transition: opacity 0.2s ease, transform 0.2s ease;
    }
    
    .wf-bar:hover {
      transform: scale(1.02);
    }
    
    .chart-fade-in {
      animation: fade-in 0.5s ease-out;
    }
    
    @keyframes fade-in {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
  </style>
</head>
<body class="bg-gray-50 text-slate-900">
  <div class="max-w-4xl mx-auto p-6">
    <div class="text-center mb-8">
      <h1 class="text-4xl font-bold text-slate-900 mb-3">SpinForge</h1>
      <p class="text-lg text-slate-600 mb-2">Custom Cycling Workouts in Seconds</p>
      <p class="text-sm text-slate-500">Choose your duration and focus, then describe your preferences or press Enter to generate instantly</p>
    </div>

    <!-- Form -->
    <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6 mb-6">
      <div id="form-errors" class="w-full text-red-600 text-sm hidden mb-4"></div>
      
      <div class="flex flex-col sm:flex-row gap-4 items-end">
        <label class="block flex-1">
          <span class="text-sm font-medium text-slate-700 mb-2 block">Duration</span>
          <select name="duration_min" class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors" required aria-label="Workout duration in minutes">
            <option value="30">30 min</option><option value="45" selected>45 min</option><option value="60">60 min</option><option value="75">75 min</option><option value="90">90 min</option><option value="105">105 min</option><option value="120">120 min</option><option value="135">135 min</option><option value="150">150 min</option><option value="165">165 min</option><option value="180">180 min</option><option value="195">195 min</option><option value="210">210 min</option><option value="225">225 min</option><option value="240">240 min</option>
          </select>
        </label>

        <label class="block flex-1">
          <span class="text-sm font-medium text-slate-700 mb-2 block">Training Focus</span>
          <select name="focus" class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors" required aria-label="Training focus type">
            <option>Recovery</option>
            <option>Endurance</option>
            <option>SweetSpot</option>
            <option>Threshold</option>
            <option selected>VO2</option>
          </select>
        </label>
      </div>
    </div>

    <!-- Preview -->
    <div id="preview" class="mb-6">
      <div class="text-center text-slate-500 py-12">
        <div class="text-lg mb-2">Ready to create your workout?</div>
        <div class="text-sm">Describe your preferences below or press Enter to generate with defaults</div>
      </div>
    </div>

    <!-- Conversation -->
    <div id="chat" class="space-y-4 mb-6" aria-live="polite" aria-relevant="additions" role="log" aria-label="Workout generation conversation"></div>

    <!-- Composer -->
    <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-4 sticky bottom-6 sm:bottom-6 bottom-4">
      <div class="flex flex-col sm:flex-row items-end gap-3">
        <div class="flex-1 w-full">
          <textarea 
            id="composer" 
            rows="2" 
            class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors resize-none min-h-[44px]" 
            placeholder="Describe your workout preferences, or press Enter to generate with defaults..."
            aria-label="Workout preferences"
          ></textarea>
        </div>
        <button 
          id="btn-send" 
          class="w-full sm:w-auto px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors font-medium min-h-[44px]"
          aria-label="Generate workout"
        >
          Generate
        </button>
      </div>
      <div id="composer-error" class="text-sm text-red-600 mt-2 hidden"></div>
    </div>
  </div>

  <script>
    // -----------------------
    // Helper & Zones/Palette
    // -----------------------
    const ZONES = [
      { label: 'Z1', min: 0.00, max: 0.55, color: '#94a3b8' },    // Slate
      { label: 'Z2', min: 0.55, max: 0.75, color: '#2563eb' },    // Blue
      { label: 'Z3', min: 0.75, max: 0.90, color: '#16a34a' },    // Green
      { label: 'Z4', min: 0.90, max: 1.05, color: '#eab308' },    // Yellow
      { label: 'Z5', min: 1.05, max: 1.20, color: '#ea580c' },    // Orange
      { label: 'Z6', min: 1.20, max: Infinity, color: '#dc2626' },    // Red
    ];
    function zoneFor(p) {
      const x = Math.max(0, p || 0);
      for (const z of ZONES) {
        if (x < z.max) return z;
      }
      return ZONES[ZONES.length - 1];
    }
    function zoneColor(p) { return zoneFor(p).color; }
    function zoneLabel(p) { return zoneFor(p).label; }
    const clamp = (x, lo, hi) => Math.max(lo, Math.min(hi, x || 0));
    const fmtPct = p => `${Math.round(p*100)}%`;
    const fmtMinSec = s => {
      s = Math.round(s);
      const m = Math.floor(s/60), r = s%60;
      return r ? `${m}m ${r}s` : `${m}m`;
    };

    // Ramps als Sub-Steps splitten, damit sie schräg wirken
    function splitRamp(step, slices=24) {
      const out = [];
      const a = step.pct_ftp, b = (step.pct_ftp_end ?? step.pct_ftp);
      const T = step.duration_s;
      const dt = Math.max(1, Math.round(T / slices));
      let t = 0;
      while (t < T) {
        const t1 = Math.min(T, t + dt);
        const ratio0 = t / T;
        const ratio1 = t1 / T;
        const p0 = a + (b - a) * ratio0;
        const p1 = a + (b - a) * ratio1;
        const pm = (p0 + p1) / 2;
        out.push({ duration_s: (t1 - t), pct_ftp: pm, kind: 'steady', note: step.note });
        t = t1;
      }
      return out;
    }

    // Download-URL nur für ZWO (Zwift-only)
    function isNLMode() { return true; }
    function buildDownloadUrl() {
      const duration = document.querySelector('select[name="duration_min"]').value;
      const focus = document.querySelector('select[name="focus"]').value;
      if (isNLMode()) {
        // if we already have a refined/generated workout in memory, download exactly that
        if (window.lastWorkout) {
          const base_raw = encodeURIComponent(JSON.stringify(window.lastWorkout));
          return `/download_nl?base_raw=${base_raw}`;
        }
        const prefs = document.querySelector('textarea[name="prefs"]').value || '';
        const params = new URLSearchParams({ duration_min: String(duration), focus, prefs });
        return `/download_nl?${params.toString()}`;
      } else {
        const vary = document.querySelector('input[name="vary"]').checked ? '1' : '0';
        return `/download?duration_min=${duration}&focus=${encodeURIComponent(focus)}&vary=${vary}`;
      }
    }

    function enableDownload() {
      // Download link now only appears in chat messages
    }

    // -----------------------
    // Form Validation (Client)
    // -----------------------
    const form = document.querySelector('form');
    const errorsEl = document.getElementById('form-errors');
    const submitBtn = document.getElementById('btn-send');

    const allowedFocus = new Set(['Recovery','Endurance','SweetSpot','Threshold','VO2']);

    function setFieldError(el, on) {
      if (!el) return;
      if (on) {
        el.classList.add('border-red-500','ring-1','ring-red-300');
      } else {
        el.classList.remove('border-red-500','ring-1','ring-red-300');
      }
    }

    function showErrors(messages) {
      if (!messages || !messages.length) { clearErrors(); return; }
      errorsEl.textContent = messages.join(' · ');
      errorsEl.classList.remove('hidden');
    }

    function clearErrors() {
      errorsEl.textContent = '';
      errorsEl.classList.add('hidden');
      setFieldError(form.querySelector('select[name="duration_min"]'), false);
      setFieldError(form.querySelector('select[name="focus"]'), false);
    }

    function validateForm() {
      const messages = [];
      const durationEl = form.querySelector('select[name="duration_min"]');
      const focusEl = form.querySelector('select[name="focus"]');
      const duration = parseInt(durationEl?.value || '0', 10);
      const focus = (focusEl?.value || '').trim();

      let ok = true;
      if (!Number.isFinite(duration) || duration < 20) {
        ok = false; messages.push('Duration must be at least 20 minutes');
        setFieldError(durationEl, true);
      } else {
        setFieldError(durationEl, false);
      }
      if (!allowedFocus.has(focus)) {
        ok = false; messages.push('Invalid focus selected');
        setFieldError(focusEl, true);
      } else {
        setFieldError(focusEl, false);
      }
      return { ok, messages };
    }

    function updateModeUI() {
      // Always in NL mode now - no need to toggle
      // All UI elements are always visible
    }
    updateModeUI();

    // Form validation is now handled in the chat composer

    // -----------------------
    // Chart Rendering (SVG)
    // -----------------------
    function drawWorkoutChart(data) {
      const total = data.steps.reduce((s,x)=>s + x.d, 0);
      const W = 960;      // Zeichenfläche
      const Hmax = 180;   // Balkenhöhe (oben) - increased for better readability
      const Hmin = 32;    // Mindesthöhe (damit leichte Bereiche sichtbar sind)
      const PAD_L = 48;   // Platz für y-Achse - increased for better spacing
      const PAD_R = 8;    // rechter Innenabstand
      const H = Hmax + 42;  // + Achse
      const GAP = 2;      // Abstand zwischen Balken
      const RX = 5;       // Rundung der Ecken (mehr Rundung)

      // Dynamische Obergrenze: etwas über dem höchsten Intervall
      let maxPct = 0;
      for (const s of data.steps) {
        const a = s.pct ?? s.pct_ftp ?? 0.6;
        const b = (s.pct_end ?? s.pct_ftp_end ?? a);
        maxPct = Math.max(maxPct, a, b);
      }
      const SCALE_TOP = Math.min(3.0, Math.max(1.05, Math.ceil((maxPct + 0.05) * 20) / 20));

      // 1) Steps aufteilen in: normale Bars und Ramps (als Polygone)
      const barSteps = [];
      const rampSteps = [];
      for (const s of data.steps) {
        const dur = s.d ?? s.duration_s;         // fallback
        const a = s.pct ?? s.pct_ftp ?? 0.6;
        const b = (s.pct_end ?? s.pct_ftp_end ?? a);
        const kind = s.kind || 'steady';
        const note = s.note || '';
        if ((kind === 'warmup' || kind === 'cooldown') && b != null && Math.abs(b - a) > 1e-6) {
          rampSteps.push({ duration_s: dur, a, b, kind, note });
        } else {
          barSteps.push({ duration_s: dur, pct_ftp: a, kind, note });
        }
      }

      // 2) SVG Start + Achsen/Gitter
      const svg = [];
      svg.push(`<svg viewBox="0 0 ${W} ${H}" preserveAspectRatio="xMidYMid meet" class="w-full h-auto bg-white rounded-lg shadow-sm border border-gray-200">`);
      // Defs: Shadow + gradient for ramps
      svg.push(`
        <defs>
          <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
            <feDropShadow dx="0" dy="1" stdDeviation="1" flood-color="#000" flood-opacity="0.15"/>
          </filter>
          <linearGradient id="grad-ramp" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" stop-color="#ffffff" stop-opacity="0.0"/>
            <stop offset="100%" stop-color="#000000" stop-opacity="0.06"/>
          </linearGradient>
        </defs>
      `);

      // horizontale Zonenbänder (ohne Y-Achsen-Ticks)
      const bands = ZONES.map(z => ({ to: z.max, color: z.color }));
      let yPrev = Hmax;
      for (const b of bands) {
        const cap = Number.isFinite(b.to) ? b.to : SCALE_TOP;
        const h = Hmin + (Hmax - Hmin) * Math.min(cap, SCALE_TOP) / SCALE_TOP;
        const y = Hmax - h;
        svg.push(`<rect x="${PAD_L}" y="${y}" width="${W - PAD_L - PAD_R}" height="${Math.max(0, yPrev - y)}" fill="${b.color}" opacity="0.05"/>`);
        yPrev = y;
      }
      // Zeitlinien alle 5 Minuten
      const totalMin = Math.max(1, Math.round(total/60));
      const gridStep = (totalMin <= 45) ? 5 : 10;
      for (let m = gridStep; m < totalMin; m += gridStep) {
        const x = PAD_L + (m*60 / total) * (W - PAD_L - PAD_R);
        svg.push(`<line x1="${x}" y1="0" x2="${x}" y2="${Hmax}" stroke="#eef2ff" stroke-width="1"/>`);
        svg.push(`<text x="${x+2}" y="${Hmax+14}" font-size="10" fill="#64748b">${m}m</text>`);
      }
      // Grundlinie unten
      svg.push(`<line x1="${PAD_L}" y1="${Hmax}" x2="${W - PAD_R}" y2="${Hmax}" stroke="#e5e7eb" stroke-width="1"/>`);

      // 3) Balken
      let x = PAD_L;
      let cumulative = 0;
      let workIndex = 0;
      for (const s of [...rampSteps, ...barSteps]) { /* placeholder to compute widths later */ }

      // We must iterate original order to place elements correctly
      x = PAD_L; cumulative = 0; workIndex = 0;
      for (const s of data.steps) {
        const dur = s.d ?? s.duration_s;
        const a = s.pct ?? s.pct_ftp ?? 0.6;
        const b = (s.pct_end ?? s.pct_ftp_end ?? a);
        const kind = s.kind || 'steady';
        const note = s.note || '';
        const w = (dur / total) * (W - PAD_L - PAD_R);

        if ((kind === 'warmup' || kind === 'cooldown') && b != null && Math.abs(b - a) > 1e-6) {
          // Ramp polygon
          const p0 = clamp(a, 0.5, 3.0);
          const p1 = clamp(b, 0.5, 3.0);
          const h0 = Hmin + (Hmax - Hmin) * Math.min(p0, SCALE_TOP) / SCALE_TOP;
          const h1 = Hmin + (Hmax - Hmin) * Math.min(p1, SCALE_TOP) / SCALE_TOP;
          const y0 = Hmax - h0;
          const y1 = Hmax - h1;
          const x0 = x + GAP/2;
          const x1 = x + w - GAP/2;
          const color0 = zoneColor(p0);
          const title = `${zoneLabel(p0)}→${zoneLabel(p1)} ${fmtPct(p0)}→${fmtPct(p1)} · ${fmtMinSec(dur)}${note?(' · '+note):''}`;
          svg.push(`
            <path class="wf-bar wf-ramp" d="M ${x0} ${Hmax} L ${x0} ${y0} L ${x1} ${y1} L ${x1} ${Hmax} Z" fill="${color0}" stroke="white" stroke-width="1" filter="url(#shadow)">
              <title>${title}</title>
            </path>
          `);
        } else {
          // Normal bar
          const p = clamp(a, 0.5, 3.0);
          const h = Hmin + (Hmax - Hmin) * Math.min(p, SCALE_TOP) / SCALE_TOP;
          const y = Hmax - h;
          const color = zoneColor(p);
          const title = `${zoneLabel(p)} ${fmtPct(p)} · ${fmtMinSec(dur)}${note?(' · '+note):''}`;
          const x1 = x + GAP/2;
          const w1 = Math.max(0, w - GAP);
          svg.push(
            `<rect class="wf-bar" x="${x1}" y="${y}" width="${w1}" height="${h}" rx="${RX}" ry="${RX}" fill="${color}" stroke="white" stroke-width="1" filter="url(#shadow)">
               <title>${title}</title>
             </rect>`
          );
          // Repeat markers at the start of each Work interval
          if ((s.kind === 'steady') && /work/i.test(note)) {
            const mx = x1 + 2;
            svg.push(`<rect x="${mx}" y="${y-6}" width="2" height="6" fill="#0ea5e9" opacity="0.9"/>`);
          }
        }
        x += w;
        cumulative += dur;
      }

      svg.push(`</svg>`);

      // 4) DOM schreiben
      const chartHtml = svg.join('');
      const summaryHtml = `
        <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
          <div class="flex flex-wrap items-center gap-6 text-sm">
            <div class="flex items-center gap-2">
              <span class="text-slate-500">Workout:</span>
              <span class="font-semibold text-slate-900">${data.name}</span>
            </div>
            <div class="flex items-center gap-2">
              <span class="text-slate-500">IF:</span>
              <span class="font-semibold text-blue-600">${data.if}</span>
            </div>
            <div class="flex items-center gap-2">
              <span class="text-slate-500">TSS:</span>
              <span class="font-semibold text-orange-600">${data.tss}</span>
            </div>
            <div class="flex items-center gap-2">
              <span class="text-slate-500">Duration:</span>
              <span class="font-semibold text-slate-900">${fmtMinSec(total)}</span>
            </div>
          </div>
        </div>`;
      const legendHtml = `
        <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
          <h4 class="text-sm font-medium text-slate-700 mb-3">Training Zones</h4>
          <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-6 gap-3 text-xs">
            ${ZONES.map(z => `
              <div class="flex items-center gap-2">
                <span class="w-3 h-3 inline-block rounded-full" style="background:${z.color}"></span>
                <span class="text-slate-600">${z.label}</span>
                <span class="text-slate-500">${(z.min*100).toFixed(0)}–${Number.isFinite(z.max)?(z.max*100).toFixed(0)+'%':'+'}%</span>
              </div>
            `).join('')}
          </div>
        </div>`;

      document.getElementById('preview').innerHTML = `
        <div class="space-y-4">
          <div id="chart" class="group relative chart-fade-in">${chartHtml}<div id="tooltip" class="hidden absolute -translate-x-1/2 -translate-y-full px-3 py-2 bg-slate-900 text-white text-xs rounded-lg shadow-lg z-10">Tooltip</div></div>
          ${data.description ? `<div class="bg-white rounded-lg shadow-sm border border-gray-200 p-4 chart-fade-in"><h4 class="text-sm font-medium text-slate-700 mb-2">Description</h4><p class="text-slate-600 text-sm">${data.description}</p></div>` : ''}
          <div id="summary" class="chart-fade-in">${summaryHtml}</div>
          <div id="legend" class="chart-fade-in">${legendHtml}</div>
        </div>`;

      // Hover interactions and tooltip (with tap-to-pin)
      const chartEl = document.getElementById('chart');
      const tip = document.getElementById('tooltip');
      const bars = chartEl.querySelectorAll('.wf-bar');
      let pinned = false;
      bars.forEach((bar) => {
        bar.addEventListener('mouseenter', () => {
          if (pinned) return;
          bars.forEach(b => { if (b !== bar) b.style.opacity = '0.65'; });
          const title = bar.querySelector('title')?.textContent || '';
          tip.textContent = title;
          tip.classList.remove('hidden');
        });
        bar.addEventListener('mousemove', (ev) => {
          const rect = chartEl.getBoundingClientRect();
          const x = ev.clientX - rect.left;
          const y = ev.clientY - rect.top;
          // Better tooltip positioning
          const tooltipWidth = 200; // approximate tooltip width
          let leftPos = x;
          if (x > rect.width - tooltipWidth) {
            leftPos = x - tooltipWidth;
          }
          tip.style.left = `${leftPos}px`;
          tip.style.top = `${y - 8}px`;
        });
        bar.addEventListener('mouseleave', () => {
          if (pinned) return;
          bars.forEach(b => { b.style.opacity = '1'; });
          tip.classList.add('hidden');
        });
        bar.addEventListener('pointerdown', (ev) => {
          // Toggle pin on tap/click
          ev.preventDefault();
          pinned = !pinned;
          if (!pinned) {
            bars.forEach(b => { b.style.opacity = '1'; });
            tip.classList.add('hidden');
          } else {
            const title = bar.querySelector('title')?.textContent || '';
            tip.textContent = title;
            tip.classList.remove('hidden');
          }
        }, { passive: false });
      });
    }

    // -----------------------
    // HTMX Hooks (cancel swap + render chart)
    // -----------------------
    document.body.addEventListener('htmx:beforeSwap', (e) => {
      // cancel DOM swap for the preview form; we'll render manually
      if (e.detail.elt === form) {
        e.detail.shouldSwap = false;
        e.detail.isError = false;
      }
    });
    document.body.addEventListener('htmx:afterRequest', (e) => {
      if (e.detail.elt !== form) return;
      const resp = e.detail.xhr && e.detail.xhr.response ? e.detail.xhr.response : null;
      const data = resp ? JSON.parse(resp) : null;
      if (!data) return;
      drawWorkoutChart(data);
      enableDownload();
      if (!isNLMode()) {
        window.lastWorkout = null;
      }
    });

    // beim Laden: Download-Button deaktiviert lassen, bis ein Workout gerendert wurde
  </script>
  <script>
    // -----------------------
    // Conversational NL flow (single composer)
    // -----------------------
    function announceToScreenReader(message) {
      const announcement = document.createElement('div');
      announcement.setAttribute('aria-live', 'polite');
      announcement.setAttribute('aria-atomic', 'true');
      announcement.className = 'sr-only';
      announcement.textContent = message;
      document.body.appendChild(announcement);
      setTimeout(() => document.body.removeChild(announcement), 1000);
    }

    function addUserMsg(text) {
      const m = document.createElement('div');
      m.className = 'flex justify-end animate-slide-up';
      m.innerHTML = `<div class="max-w-[80%] bg-blue-600 text-white rounded-3xl px-4 py-3 shadow-sm" role="text">${text}</div>`;
      document.getElementById('chat').appendChild(m);
      m.scrollIntoView({ behavior: 'smooth', block: 'end' });
      announceToScreenReader(`You said: ${text}`);
    }

    function addCoachMsg(html) {
      const m = document.createElement('div');
      m.className = 'flex justify-start animate-slide-up';
      m.innerHTML = `<div class="max-w-[80%] bg-white rounded-3xl px-4 py-3 shadow-sm border border-gray-200" role="text">${html}</div>`;
      document.getElementById('chat').appendChild(m);
      m.scrollIntoView({ behavior: 'smooth', block: 'end' });
      announceToScreenReader('Coach generated a new workout');
    }

    function showChartMessage(data) {
      // remove any previous chart message
      document.querySelectorAll('.chart-message').forEach(el => el.remove());

      // First render using existing renderer into hidden preview, then move pieces
      drawWorkoutChart(data);
      const prev = document.getElementById('preview');
      const chart = prev.querySelector('#chart');
      const summary = prev.querySelector('#summary');
      const desc = prev.querySelector('#desc');
      const legend = prev.querySelector('#legend');

      const wrap = document.createElement('div');
      wrap.className = 'chart-message flex justify-start animate-slide-up';
      const card = document.createElement('div');
      card.className = 'max-w-[80%] bg-white rounded-3xl px-4 py-4 shadow-sm border border-gray-200';
      const header = `
        <div class="flex items-center justify-between mb-3">
          <div class="font-semibold text-slate-900">${data.name}</div>
          <a class="inline-flex items-center gap-2 px-4 py-2 bg-sky-600 text-white rounded-lg hover:bg-sky-700 focus:ring-2 focus:ring-sky-500 focus:ring-offset-2 transition-colors text-sm font-medium" href="${buildDownloadUrl()}" aria-label="Download workout file">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
            </svg>
            Download .zwo
          </a>
        </div>
      `;
      card.innerHTML = header;
      const body = document.createElement('div');
      body.className = 'space-y-2';
      if (chart) body.appendChild(chart);
      if (summary) body.appendChild(summary);
      if (desc) body.appendChild(desc);
      if (legend) body.appendChild(legend);
      card.appendChild(body);
      wrap.appendChild(card);
      document.getElementById('chat').appendChild(wrap);
      // clear preview to avoid duplicates
      prev.innerHTML = '';
      wrap.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }

    const sendBtn = document.getElementById('btn-send');
    const composer = document.getElementById('composer');
    
    function setLoadingState(loading) {
      if (loading) {
        sendBtn.disabled = true;
        sendBtn.textContent = 'Generating...';
        sendBtn.classList.add('opacity-50', 'cursor-not-allowed');
        composer.disabled = true;
        composer.placeholder = 'Generating your workout...';
      } else {
        sendBtn.disabled = false;
        sendBtn.textContent = 'Generate';
        sendBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        composer.disabled = false;
        composer.placeholder = 'Describe your workout preferences, or press Enter to generate with defaults...';
      }
    }

    async function generateWorkout() {
      const text = (composer.value || '').trim();
      const duration = document.querySelector('select[name="duration_min"]').value;
      const focus = document.querySelector('select[name="focus"]').value;
      
      // Validate form
      const durationEl = document.querySelector('select[name="duration_min"]');
      const focusEl = document.querySelector('select[name="focus"]');
      const errors = [];
      
      if (!durationEl.value) errors.push('Please select a duration');
      if (!focusEl.value) errors.push('Please select a focus');
      
      if (errors.length > 0) {
        document.getElementById('form-errors').textContent = errors.join(' · ');
        document.getElementById('form-errors').classList.remove('hidden');
        return;
      }
      
      document.getElementById('form-errors').classList.add('hidden');
      document.getElementById('composer-error').classList.add('hidden');
      
      setLoadingState(true);
      
      if (text) addUserMsg(text);

      try {
        let url, body;
        if (window.lastWorkout) {
          url = '/preview_nl_refine';
          body = new FormData();
          body.set('duration_min', String(duration));
          body.set('focus', focus);
          body.set('changes', text);
          body.set('base_raw', JSON.stringify(window.lastWorkout));
        } else {
          url = '/preview_nl';
          body = new FormData();
          body.set('duration_min', String(duration));
          body.set('focus', focus);
          body.set('prefs', text);
        }

        const resp = await fetch(url, { method: 'POST', body });
        if (!resp.ok) {
          throw new Error('Failed to generate workout');
        }
        
        const data = await resp.json();
        window.lastWorkout = data;
        
        if (window.lastWorkout) {
          addCoachMsg('<div class="text-sm text-slate-700 mb-2">Here\'s your refined workout.</div>');
        } else {
          addCoachMsg('<div class="text-sm text-slate-700 mb-2">Here\'s a workout based on your preferences.</div>');
        }
        
        showChartMessage(data);
        enableDownload();
        composer.value = '';
        composer.focus();
        
      } catch (error) {
        document.getElementById('composer-error').textContent = 'Sorry, I had trouble generating your workout. Please try again.';
        document.getElementById('composer-error').classList.remove('hidden');
      } finally {
        setLoadingState(false);
      }
    }

    if (sendBtn) {
      sendBtn.addEventListener('click', generateWorkout);
    }
    
    if (composer) {
      composer.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          generateWorkout();
        }
      });
    }
  </script>
</body>
</html>
