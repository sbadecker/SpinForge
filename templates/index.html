<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>RoadForge – Workouts in Sekunden</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <script src="https://unpkg.com/htmx.org@1.9.12"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-slate-50 text-slate-900">
  <div class="max-w-4xl mx-auto p-6">
    <h1 class="text-2xl font-bold mb-1">Custom Cycling Workouts in Seconds – Ready for Zwift</h1>
    <p class="text-slate-600 mb-6">Choose duration & focus → Generate → Download as .zwo</p>

    <!-- Form -->
    <form class="flex flex-wrap gap-3 items-end"
          hx-post="/preview" hx-trigger="submit"
          hx-target="#preview" hx-swap="none" id="wf" novalidate>
      <div id="form-errors" class="w-full text-red-600 text-sm hidden"></div>

      <!-- Mode toggle -->
      <fieldset id="mode-form" class="flex items-center gap-2 w-full">
        <span class="text-sm text-slate-600 mr-2">Mode</span>
        <label class="inline-flex items-center gap-1 text-sm">
          <input type="radio" name="mode" value="form" class="w-4 h-4">
          Structured
        </label>
        <label class="inline-flex items-center gap-1 text-sm">
          <input type="radio" name="mode" value="nl" class="w-4 h-4" checked>
          Natural language
        </label>
      </fieldset>
      <label class="block">
        <span class="text-sm">Duration (min)</span>
        <select name="duration_min" class="px-3 py-2 border rounded" required>
          <option>30</option><option selected>45</option><option>60</option><option>75</option><option>90</option><option>105</option><option>120</option><option>135</option><option>150</option><option>165</option><option>180</option><option>195</option><option>210</option><option>225</option><option>240</option>
        </select>
      </label>

      <label class="block">
        <span class="text-sm">Focus</span>
        <select name="focus" class="px-3 py-2 border rounded" required>
          <option>Recovery</option>
          <option>Endurance</option>
          <option>SweetSpot</option>
          <option>Threshold</option>
          <option selected>VO2</option>
        </select>
      </label>

      <label id="row-vary" class="inline-flex items-center gap-2">
        <input type="checkbox" name="vary" class="w-4 h-4">
        <span class="text-sm">Variation</span>
      </label>

      <!-- NL preferences -->
      <label id="row-prefs" class="block w-full hidden">
        <span class="text-sm">Preferences (free text)</span>
        <textarea name="prefs" rows="3" class="w-full px-3 py-2 border rounded" placeholder="e.g., 3x8min @ Z4 with 4min Z2 recoveries; include 10min warmup & cooldown"></textarea>
      </label>
      <button id="btn-submit" class="px-4 py-2 bg-blue-600 text-white rounded">Generate workout</button>
    </form>

    <!-- Actions (Download etc.) -->
    <div class="mt-4 flex gap-3" id="actions-row">
      <a id="btn-zwo" href="#" class="px-3 py-2 bg-slate-900 text-white rounded pointer-events-none opacity-50">Download .zwo</a>
      <button id="btn-regenerate" class="px-3 py-2 border rounded hidden">Regenerate</button>
    </div>

    <!-- Preview -->
    <div id="preview" class="mt-6 text-sm text-slate-800">
      <div class="text-slate-500">No workout generated yet.</div>
    </div>

    <!-- Conversation (NL mode) -->
    <div id="chat" class="mt-6 space-y-4 hidden" aria-live="polite" aria-relevant="additions"></div>

    <!-- Composer (NL mode) -->
    <div id="composer-wrap" class="mt-4 border rounded bg-white p-3 sticky bottom-0 hidden">
      <div class="flex flex-wrap gap-2 mb-2">
        <select name="duration_min" class="px-3 py-2 border rounded">
          <option>30</option><option selected>45</option><option>60</option><option>75</option><option>90</option>
        </select>
        <select name="focus" class="px-3 py-2 border rounded">
          <option>Recovery</option><option>Endurance</option><option>SweetSpot</option><option>Threshold</option><option selected>VO2</option>
        </select>
      </div>
      <div class="flex items-start gap-2">
        <textarea id="composer" rows="2" class="flex-1 px-3 py-2 border rounded" placeholder="Tell your coach what you want… e.g., Add two short sprints near the end"></textarea>
        <button id="btn-send" class="px-4 py-2 bg-blue-600 text-white rounded">Send to coach</button>
      </div>
      <div id="composer-error" class="text-sm text-red-600 mt-2 hidden"></div>
    </div>
  </div>

  <script>
    // -----------------------
    // Helper & Zones/Palette
    // -----------------------
    const ZONES = [
      { label: 'Z1', min: 0.00, max: 0.55, color: '#9ca3af' },    // Grey
      { label: 'Z2', min: 0.55, max: 0.75, color: '#3b82f6' },    // Blue
      { label: 'Z3', min: 0.75, max: 0.90, color: '#22c55e' },    // Green
      { label: 'Z4', min: 0.90, max: 1.05, color: '#f59e0b' },    // Yellow
      { label: 'Z5', min: 1.05, max: 1.20, color: '#f97316' },    // Orange
      { label: 'Z6', min: 1.20, max: Infinity, color: '#ef4444' },    // Red (open-ended)
    ];
    function zoneFor(p) {
      const x = Math.max(0, p || 0);
      for (const z of ZONES) {
        if (x < z.max) return z;
      }
      return ZONES[ZONES.length - 1];
    }
    function zoneColor(p) { return zoneFor(p).color; }
    function zoneLabel(p) { return zoneFor(p).label; }
    const clamp = (x, lo, hi) => Math.max(lo, Math.min(hi, x || 0));
    const fmtPct = p => `${Math.round(p*100)}%`;
    const fmtMinSec = s => {
      s = Math.round(s);
      const m = Math.floor(s/60), r = s%60;
      return r ? `${m}m ${r}s` : `${m}m`;
    };

    // Ramps als Sub-Steps splitten, damit sie schräg wirken
    function splitRamp(step, slices=24) {
      const out = [];
      const a = step.pct_ftp, b = (step.pct_ftp_end ?? step.pct_ftp);
      const T = step.duration_s;
      const dt = Math.max(1, Math.round(T / slices));
      let t = 0;
      while (t < T) {
        const t1 = Math.min(T, t + dt);
        const ratio0 = t / T;
        const ratio1 = t1 / T;
        const p0 = a + (b - a) * ratio0;
        const p1 = a + (b - a) * ratio1;
        const pm = (p0 + p1) / 2;
        out.push({ duration_s: (t1 - t), pct_ftp: pm, kind: 'steady', note: step.note });
        t = t1;
      }
      return out;
    }

    // Download-URL nur für ZWO (Zwift-only)
    function isNLMode() {
      const m = document.querySelector('input[name="mode"]:checked');
      return m && m.value === 'nl';
    }
    function buildDownloadUrl() {
      const duration = document.querySelector('select[name="duration_min"]').value;
      const focus = document.querySelector('select[name="focus"]').value;
      if (isNLMode()) {
        // if we already have a refined/generated workout in memory, download exactly that
        if (window.lastWorkout) {
          const base_raw = encodeURIComponent(JSON.stringify(window.lastWorkout));
          return `/download_nl?base_raw=${base_raw}`;
        }
        const prefs = document.querySelector('textarea[name="prefs"]').value || '';
        const params = new URLSearchParams({ duration_min: String(duration), focus, prefs });
        return `/download_nl?${params.toString()}`;
      } else {
        const vary = document.querySelector('input[name="vary"]').checked ? '1' : '0';
        return `/download?duration_min=${duration}&focus=${encodeURIComponent(focus)}&vary=${vary}`;
      }
    }

    function enableDownload() {
      const a = document.getElementById('btn-zwo');
      a.href = buildDownloadUrl();
      a.classList.remove('opacity-50','pointer-events-none');
      const reg = document.getElementById('btn-regenerate');
      if (!isNLMode()) {
        reg.classList.remove('hidden');
        reg.onclick = () => document.getElementById('wf').dispatchEvent(new Event('submit',{cancelable:true}));
      } else {
        reg.classList.add('hidden');
      }
    }

    // -----------------------
    // Form Validation (Client)
    // -----------------------
    const form = document.getElementById('wf');
    const errorsEl = document.getElementById('form-errors');
    const submitBtn = document.getElementById('btn-submit');
    const downloadBtn = document.getElementById('btn-zwo');

    const allowedFocus = new Set(['Recovery','Endurance','SweetSpot','Threshold','VO2']);

    function setFieldError(el, on) {
      if (!el) return;
      if (on) {
        el.classList.add('border-red-500','ring-1','ring-red-300');
      } else {
        el.classList.remove('border-red-500','ring-1','ring-red-300');
      }
    }

    function showErrors(messages) {
      if (!messages || !messages.length) { clearErrors(); return; }
      errorsEl.textContent = messages.join(' · ');
      errorsEl.classList.remove('hidden');
    }

    function clearErrors() {
      errorsEl.textContent = '';
      errorsEl.classList.add('hidden');
      setFieldError(form.querySelector('select[name="duration_min"]'), false);
      setFieldError(form.querySelector('select[name="focus"]'), false);
    }

    function validateForm() {
      const messages = [];
      const durationEl = form.querySelector('select[name="duration_min"]');
      const focusEl = form.querySelector('select[name="focus"]');
      const duration = parseInt(durationEl?.value || '0', 10);
      const focus = (focusEl?.value || '').trim();

      let ok = true;
      if (!Number.isFinite(duration) || duration < 20) {
        ok = false; messages.push('Duration must be at least 20 minutes');
        setFieldError(durationEl, true);
      } else {
        setFieldError(durationEl, false);
      }
      if (!allowedFocus.has(focus)) {
        ok = false; messages.push('Invalid focus selected');
        setFieldError(focusEl, true);
      } else {
        setFieldError(focusEl, false);
      }
      return { ok, messages };
    }

    function updateModeUI() {
      // toggle endpoint
      form.setAttribute('hx-post', isNLMode() ? '/preview_nl' : '/preview');
      // toggle fields
      // In chat (NL) mode, hide the old free-text preferences field
      document.getElementById('row-prefs').classList.toggle('hidden', isNLMode());
      document.getElementById('row-vary').classList.toggle('hidden', isNLMode());
      // chat vs preview
      document.getElementById('chat').classList.toggle('hidden', !isNLMode());
      document.getElementById('composer-wrap').classList.toggle('hidden', !isNLMode());
      document.getElementById('preview').classList.toggle('hidden', isNLMode());
      document.getElementById('btn-submit').classList.toggle('hidden', isNLMode());
      document.getElementById('actions-row').classList.toggle('hidden', false);
    }
    updateModeUI();
    document.getElementById('mode-form').addEventListener('change', () => {
      updateModeUI();
    });

    form.addEventListener('submit', (e) => {
      const { ok, messages } = validateForm();
      if (!ok) {
        e.preventDefault();
        showErrors(messages);
        // keep download disabled until valid render
        downloadBtn.classList.add('opacity-50','pointer-events-none');
      } else {
        clearErrors();
      }
    });

    form.addEventListener('change', () => {
      // re-validate on any change
      const { ok, messages } = validateForm();
      if (ok) clearErrors(); else showErrors(messages);
    });

    // Disable submit during request & surface HTMX errors
    document.body.addEventListener('htmx:beforeRequest', (e) => {
      if (e.detail.elt === form) {
        submitBtn.setAttribute('disabled','');
        submitBtn.classList.add('opacity-50','cursor-not-allowed');
      }
    });
    document.body.addEventListener('htmx:afterRequest', (e) => {
      if (e.detail.elt === form) {
        submitBtn.removeAttribute('disabled');
        submitBtn.classList.remove('opacity-50','cursor-not-allowed');
        clearErrors();
      }
    });
    document.body.addEventListener('htmx:responseError', (e) => {
      if (e.detail.elt === form) {
        showErrors(['Server error while generating the workout']);
        submitBtn.removeAttribute('disabled');
        submitBtn.classList.remove('opacity-50','cursor-not-allowed');
      }
    });

    // -----------------------
    // Chart Rendering (SVG)
    // -----------------------
    function drawWorkoutChart(data) {
      const total = data.steps.reduce((s,x)=>s + x.d, 0);
      const W = 960;      // Zeichenfläche
      const Hmax = 160;   // Balkenhöhe (oben)
      const Hmin = 28;    // Mindesthöhe (damit leichte Bereiche sichtbar sind)
      const PAD_L = 42;   // Platz für y-Achse
      const PAD_R = 6;    // rechter Innenabstand
      const H = Hmax + 38;  // + Achse
      const GAP = 2;      // Abstand zwischen Balken
      const RX = 5;       // Rundung der Ecken (mehr Rundung)

      // Dynamische Obergrenze: etwas über dem höchsten Intervall
      let maxPct = 0;
      for (const s of data.steps) {
        const a = s.pct ?? s.pct_ftp ?? 0.6;
        const b = (s.pct_end ?? s.pct_ftp_end ?? a);
        maxPct = Math.max(maxPct, a, b);
      }
      const SCALE_TOP = Math.min(3.0, Math.max(1.05, Math.ceil((maxPct + 0.05) * 20) / 20));

      // 1) Steps aufteilen in: normale Bars und Ramps (als Polygone)
      const barSteps = [];
      const rampSteps = [];
      for (const s of data.steps) {
        const dur = s.d ?? s.duration_s;         // fallback
        const a = s.pct ?? s.pct_ftp ?? 0.6;
        const b = (s.pct_end ?? s.pct_ftp_end ?? a);
        const kind = s.kind || 'steady';
        const note = s.note || '';
        if ((kind === 'warmup' || kind === 'cooldown') && b != null && Math.abs(b - a) > 1e-6) {
          rampSteps.push({ duration_s: dur, a, b, kind, note });
        } else {
          barSteps.push({ duration_s: dur, pct_ftp: a, kind, note });
        }
      }

      // 2) SVG Start + Achsen/Gitter
      const svg = [];
      svg.push(`<svg viewBox="0 0 ${W} ${H}" preserveAspectRatio="xMidYMid meet" class="w-full h-auto bg-white rounded ring-1 ring-slate-200">`);
      // Defs: Shadow + gradient for ramps
      svg.push(`
        <defs>
          <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
            <feDropShadow dx="0" dy="1" stdDeviation="1" flood-color="#000" flood-opacity="0.15"/>
          </filter>
          <linearGradient id="grad-ramp" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" stop-color="#ffffff" stop-opacity="0.0"/>
            <stop offset="100%" stop-color="#000000" stop-opacity="0.06"/>
          </linearGradient>
        </defs>
      `);

      // horizontale Zonenbänder (ohne Y-Achsen-Ticks)
      const bands = ZONES.map(z => ({ to: z.max, color: z.color }));
      let yPrev = Hmax;
      for (const b of bands) {
        const cap = Number.isFinite(b.to) ? b.to : SCALE_TOP;
        const h = Hmin + (Hmax - Hmin) * Math.min(cap, SCALE_TOP) / SCALE_TOP;
        const y = Hmax - h;
        svg.push(`<rect x="${PAD_L}" y="${y}" width="${W - PAD_L - PAD_R}" height="${Math.max(0, yPrev - y)}" fill="${b.color}" opacity="0.05"/>`);
        yPrev = y;
      }
      // Zeitlinien alle 5 Minuten
      const totalMin = Math.max(1, Math.round(total/60));
      const gridStep = (totalMin <= 45) ? 5 : 10;
      for (let m = gridStep; m < totalMin; m += gridStep) {
        const x = PAD_L + (m*60 / total) * (W - PAD_L - PAD_R);
        svg.push(`<line x1="${x}" y1="0" x2="${x}" y2="${Hmax}" stroke="#eef2ff" stroke-width="1"/>`);
        svg.push(`<text x="${x+2}" y="${Hmax+14}" font-size="10" fill="#64748b">${m}m</text>`);
      }
      // Grundlinie unten
      svg.push(`<line x1="${PAD_L}" y1="${Hmax}" x2="${W - PAD_R}" y2="${Hmax}" stroke="#e5e7eb" stroke-width="1"/>`);

      // 3) Balken
      let x = PAD_L;
      let cumulative = 0;
      let workIndex = 0;
      for (const s of [...rampSteps, ...barSteps]) { /* placeholder to compute widths later */ }

      // We must iterate original order to place elements correctly
      x = PAD_L; cumulative = 0; workIndex = 0;
      for (const s of data.steps) {
        const dur = s.d ?? s.duration_s;
        const a = s.pct ?? s.pct_ftp ?? 0.6;
        const b = (s.pct_end ?? s.pct_ftp_end ?? a);
        const kind = s.kind || 'steady';
        const note = s.note || '';
        const w = (dur / total) * (W - PAD_L - PAD_R);

        if ((kind === 'warmup' || kind === 'cooldown') && b != null && Math.abs(b - a) > 1e-6) {
          // Ramp polygon
          const p0 = clamp(a, 0.5, 3.0);
          const p1 = clamp(b, 0.5, 3.0);
          const h0 = Hmin + (Hmax - Hmin) * Math.min(p0, SCALE_TOP) / SCALE_TOP;
          const h1 = Hmin + (Hmax - Hmin) * Math.min(p1, SCALE_TOP) / SCALE_TOP;
          const y0 = Hmax - h0;
          const y1 = Hmax - h1;
          const x0 = x + GAP/2;
          const x1 = x + w - GAP/2;
          const color0 = zoneColor(p0);
          const title = `${zoneLabel(p0)}→${zoneLabel(p1)} ${fmtPct(p0)}→${fmtPct(p1)} · ${fmtMinSec(dur)}${note?(' · '+note):''}`;
          svg.push(`
            <path class="wf-bar wf-ramp" d="M ${x0} ${Hmax} L ${x0} ${y0} L ${x1} ${y1} L ${x1} ${Hmax} Z" fill="${color0}" stroke="white" stroke-width="1" filter="url(#shadow)">
              <title>${title}</title>
            </path>
          `);
        } else {
          // Normal bar
          const p = clamp(a, 0.5, 3.0);
          const h = Hmin + (Hmax - Hmin) * Math.min(p, SCALE_TOP) / SCALE_TOP;
          const y = Hmax - h;
          const color = zoneColor(p);
          const title = `${zoneLabel(p)} ${fmtPct(p)} · ${fmtMinSec(dur)}${note?(' · '+note):''}`;
          const x1 = x + GAP/2;
          const w1 = Math.max(0, w - GAP);
          svg.push(
            `<rect class="wf-bar" x="${x1}" y="${y}" width="${w1}" height="${h}" rx="${RX}" ry="${RX}" fill="${color}" stroke="white" stroke-width="1" filter="url(#shadow)">
               <title>${title}</title>
             </rect>`
          );
          // Repeat markers at the start of each Work interval
          if ((s.kind === 'steady') && /work/i.test(note)) {
            const mx = x1 + 2;
            svg.push(`<rect x="${mx}" y="${y-6}" width="2" height="6" fill="#0ea5e9" opacity="0.9"/>`);
          }
        }
        x += w;
        cumulative += dur;
      }

      svg.push(`</svg>`);

      // 4) DOM schreiben
      const chartHtml = svg.join('');
      const summaryHtml = `Name: <b>${data.name}</b> · IF <b>${data.if}</b> · TSS <b>${data.tss}</b> · Duration <b>${fmtMinSec(total)}</b>`;
      const legendHtml = `
        <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-6 gap-2 text-xs">
          ${ZONES.map(z => `
            <div class="flex items-center gap-2">
              <span class="w-3 h-3 inline-block rounded" style="background:${z.color}"></span>
              ${z.label} ${(z.min*100).toFixed(0)}–${Number.isFinite(z.max)?(z.max*100).toFixed(0)+'%':'+'}
            </div>
          `).join('')}
        </div>`;

      document.getElementById('preview').innerHTML = `
        <div class="space-y-3">
          <div id="chart" class="group relative">${chartHtml}<div id="tooltip" class="hidden absolute -translate-x-1/2 -translate-y-full px-2 py-1 bg-slate-900 text-white text-xs rounded shadow">Tooltip</div></div>
          <div id="summary" class="text-slate-700">${summaryHtml}</div>
          ${data.description ? `<div id="desc" class="text-slate-700"><b>Description:</b> ${data.description}</div>` : ''}
          <div id="legend" class="mt-2">${legendHtml}</div>
        </div>`;

      // Hover interactions and tooltip (with tap-to-pin)
      const chartEl = document.getElementById('chart');
      const tip = document.getElementById('tooltip');
      const bars = chartEl.querySelectorAll('.wf-bar');
      let pinned = false;
      bars.forEach((bar) => {
        bar.addEventListener('mouseenter', () => {
          if (pinned) return;
          bars.forEach(b => { if (b !== bar) b.style.opacity = '0.65'; });
          const title = bar.querySelector('title')?.textContent || '';
          tip.textContent = title;
          tip.classList.remove('hidden');
        });
        bar.addEventListener('mousemove', (ev) => {
          const rect = chartEl.getBoundingClientRect();
          const x = ev.clientX - rect.left;
          const y = ev.clientY - rect.top;
          tip.style.left = `${x}px`;
          tip.style.top = `${y - 6}px`;
        });
        bar.addEventListener('mouseleave', () => {
          if (pinned) return;
          bars.forEach(b => { b.style.opacity = '1'; });
          tip.classList.add('hidden');
        });
        bar.addEventListener('pointerdown', (ev) => {
          // Toggle pin on tap/click
          ev.preventDefault();
          pinned = !pinned;
          if (!pinned) {
            bars.forEach(b => { b.style.opacity = '1'; });
            tip.classList.add('hidden');
          } else {
            const title = bar.querySelector('title')?.textContent || '';
            tip.textContent = title;
            tip.classList.remove('hidden');
          }
        }, { passive: false });
      });
    }

    // -----------------------
    // HTMX Hooks (cancel swap + render chart)
    // -----------------------
    document.body.addEventListener('htmx:beforeSwap', (e) => {
      // cancel DOM swap for the preview form; we'll render manually
      if (e.detail.elt === form) {
        e.detail.shouldSwap = false;
        e.detail.isError = false;
      }
    });
    document.body.addEventListener('htmx:afterRequest', (e) => {
      if (e.detail.elt !== form) return;
      const resp = e.detail.xhr && e.detail.xhr.response ? e.detail.xhr.response : null;
      const data = resp ? JSON.parse(resp) : null;
      if (!data) return;
      drawWorkoutChart(data);
      enableDownload();
      if (!isNLMode()) {
        window.lastWorkout = null;
      }
    });

    // beim Laden: Download-Button deaktiviert lassen, bis ein Workout gerendert wurde
  </script>
  <script>
    // -----------------------
    // Conversational NL flow (single composer)
    // -----------------------
    function addUserMsg(text) {
      const m = document.createElement('div');
      m.className = 'flex justify-end';
      m.innerHTML = `<div class="max-w-[80%] bg-blue-600 text-white rounded-2xl px-3 py-2">${text}</div>`;
      document.getElementById('chat').appendChild(m);
      m.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }

    function addCoachMsg(html) {
      const m = document.createElement('div');
      m.className = 'flex justify-start';
      m.innerHTML = `<div class="max-w-[80%] bg-white rounded-2xl px-3 py-2 ring-1 ring-slate-200">${html}</div>`;
      document.getElementById('chat').appendChild(m);
      m.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }

    function showChartMessage(data) {
      // remove any previous chart message
      document.querySelectorAll('.chart-message').forEach(el => el.remove());

      // First render using existing renderer into hidden preview, then move pieces
      drawWorkoutChart(data);
      const prev = document.getElementById('preview');
      const chart = prev.querySelector('#chart');
      const summary = prev.querySelector('#summary');
      const desc = prev.querySelector('#desc');
      const legend = prev.querySelector('#legend');

      const wrap = document.createElement('div');
      wrap.className = 'chart-message flex justify-start';
      const card = document.createElement('div');
      card.className = 'max-w-[80%] bg-white rounded-2xl px-3 py-3 ring-1 ring-slate-200';
      const header = `
        <div class="flex items-center justify-between mb-2">
          <div class="font-medium">${data.name}</div>
          <a class="px-2 py-1 bg-slate-900 text-white rounded text-sm" href="${buildDownloadUrl()}">Download .zwo</a>
        </div>
      `;
      card.innerHTML = header;
      const body = document.createElement('div');
      body.className = 'space-y-2';
      if (chart) body.appendChild(chart);
      if (summary) body.appendChild(summary);
      if (desc) body.appendChild(desc);
      if (legend) body.appendChild(legend);
      card.appendChild(body);
      wrap.appendChild(card);
      document.getElementById('chat').appendChild(wrap);
      // clear preview to avoid duplicates
      prev.innerHTML = '';
      wrap.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }

    const sendBtn = document.getElementById('btn-send');
    if (sendBtn) {
      sendBtn.addEventListener('click', async () => {
        const text = (document.getElementById('composer').value || '').trim();
        const duration = document.querySelector('select[name="duration_min"]').value;
        const focus = document.querySelector('select[name="focus"]').value;
        if (!text && !window.lastWorkout) return; // need initial prompt

        document.getElementById('composer-error').classList.add('hidden');
        if (text) addUserMsg(text);

        let url, body;
        if (window.lastWorkout) {
          url = '/preview_nl_refine';
          body = new FormData();
          body.set('duration_min', String(duration));
          body.set('focus', focus);
          body.set('changes', text);
          body.set('base_raw', JSON.stringify(window.lastWorkout));
        } else {
          url = '/preview_nl';
          body = new FormData();
          body.set('duration_min', String(duration));
          body.set('focus', focus);
          body.set('prefs', text);
        }

        const resp = await fetch(url, { method: 'POST', body });
        if (!resp.ok) {
          document.getElementById('composer-error').textContent = 'Coach had trouble generating a workout. Please try again.';
          document.getElementById('composer-error').classList.remove('hidden');
          return;
        }
        const data = await resp.json();
        window.lastWorkout = data;
        addCoachMsg('<div class="text-sm text-slate-700 mb-2">Here’s a session based on your request.</div>');
        showChartMessage(data);
        enableDownload();
        document.getElementById('composer').value = '';
      });
    }
  </script>
</body>
</html>
